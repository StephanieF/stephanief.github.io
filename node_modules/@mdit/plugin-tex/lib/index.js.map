{"version":3,"file":"index.js","sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked from https://github.com/waylonflinn/markdown-it-katex/blob/master/index.js\n */\n\nimport type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline.mjs\";\n\nimport type { MarkdownItTexOptions } from \"./options.js\";\n\n/*\n * Test if potential opening or closing delimiter for dollar syntax\n * Assumes that there is a \"$\" at state.src[pos]\n */\nconst isValidDollarDelim = (\n  state: StateInline,\n  pos: number,\n  allowInlineWithSpace: boolean,\n): { canOpen: boolean; canClose: boolean } => {\n  const prevChar = state.src.charAt(pos - 1);\n  const nextChar = state.src.charAt(pos + 1);\n\n  return {\n    canOpen: allowInlineWithSpace || (nextChar !== \" \" && nextChar !== \"\\t\"),\n\n    /*\n     * Check non-whitespace conditions for opening and closing, and\n     * check that closing delimiter isn't followed by a number\n     */\n    canClose:\n      !/[0-9]/u.exec(nextChar) &&\n      (allowInlineWithSpace || (prevChar !== \" \" && prevChar !== \"\\t\")),\n  };\n};\n\n/*\n * Parse inline math with dollar signs: $...$\n */\nconst getDollarInlineTex =\n  (allowInlineWithSpace: boolean): RuleInline =>\n  (state, silent) => {\n    if (state.src[state.pos] !== \"$\") return false;\n\n    let delimState = isValidDollarDelim(state, state.pos, allowInlineWithSpace);\n\n    if (!delimState.canOpen) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos++;\n\n      return true;\n    }\n\n    /*\n     * First check for and bypass all properly escaped delimiters\n     * This loop will assume that the first leading backtick can not\n     * be the first character in state.src, which is known since\n     * we have found an opening delimiter already.\n     */\n    const start = state.pos + 1;\n\n    let match = start;\n    let pos: number;\n\n    while ((match = state.src.indexOf(\"$\", match)) !== -1) {\n      /*\n       * Found potential $, look for escapes, pos will point to\n       * first non escape when complete\n       */\n      pos = match - 1;\n      while (state.src[pos] === \"\\\\\") pos--;\n\n      // Even number of escapes, potential closing delimiter found\n      if ((match - pos) % 2 === 1) break;\n\n      match++;\n    }\n\n    // No closing delimiter found.  Consume $ and continue.\n    if (match === -1) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n      if (!silent) state.pending += \"$$\";\n\n      state.pos = start + 1;\n\n      return true;\n    }\n\n    // Check for valid closing delimiter\n    delimState = isValidDollarDelim(state, match, allowInlineWithSpace);\n\n    if (!delimState.canClose) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    if (!silent) {\n      const token = state.push(\"math_inline\", \"math\", 0);\n\n      token.markup = \"$\";\n      token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n\n    return true;\n  };\n\n/*\n * Parse inline math with bracket syntax: \\(...\\)\n */\nconst getBracketInlineTex = (): RuleInline => (state, silent) => {\n  const start = state.pos;\n\n  // Check for opening \\(\n  if (state.src.slice(start, start + 2) !== \"\\\\(\") return false;\n\n  // Look for closing \\)\n  let pos = start + 2;\n  let found = false;\n\n  while (pos < state.src.length - 1) {\n    if (state.src.slice(pos, pos + 2) === \"\\\\)\") {\n      // Check if the opening \\( was escaped\n      let backslashes = 0;\n      let checkPos = start - 1;\n\n      while (checkPos >= 0 && state.src[checkPos] === \"\\\\\") {\n        backslashes++;\n        checkPos--;\n      }\n\n      // If opening \\( is escaped (odd number of preceding backslashes), don't parse\n      if (backslashes % 2 === 1) return false;\n\n      // Check if the closing \\) is escaped\n      let closingBackslashes = 0;\n      let closingCheckPos = pos - 1;\n\n      while (\n        closingCheckPos >= start + 2 &&\n        state.src[closingCheckPos] === \"\\\\\"\n      ) {\n        closingBackslashes++;\n        closingCheckPos--;\n      }\n\n      // If closing \\) is not escaped (even number of preceding backslashes), we found it\n      if (closingBackslashes % 2 === 0) {\n        found = true;\n        break;\n      }\n    }\n    pos++;\n  }\n\n  if (!found) return false;\n\n  if (!silent) {\n    const token = state.push(\"math_inline\", \"math\", 0);\n\n    token.markup = \"\\\\(\";\n    token.content = state.src.slice(start + 2, pos);\n  }\n\n  state.pos = pos + 2;\n\n  return true;\n};\n\n/*\n * Parse block math with dollar signs: $$...$$\n */\nconst getDollarBlockTex = (): RuleBlock => (state, start, end, silent) => {\n  let pos = state.bMarks[start] + state.tShift[start];\n  let max = state.eMarks[start];\n\n  if (pos + 2 > max) return false;\n\n  if (state.src.slice(pos, pos + 2) !== \"$$\") return false;\n\n  pos += 2;\n  let firstLine = state.src.slice(pos, max).trim();\n\n  if (silent) return true;\n\n  let found = false;\n\n  if (firstLine.endsWith(\"$$\")) {\n    // Single line expression\n    firstLine = firstLine.slice(0, -2);\n    found = true;\n  }\n\n  let current = start;\n  let lastLine = \"\";\n\n  while (!found) {\n    current++;\n    if (current >= end) break;\n\n    pos = state.bMarks[current] + state.tShift[current];\n    max = state.eMarks[current];\n\n    // non-empty line with negative indent should stop the list:\n    if (pos < max && state.tShift[current] < state.blkIndent) break;\n\n    // found end marker\n    if (state.src.slice(pos, max).trim().endsWith(\"$$\")) {\n      lastLine = state.src\n        .slice(pos, state.src.slice(0, max).lastIndexOf(\"$$\"))\n        .trim();\n      found = true;\n    }\n  }\n\n  state.line = found ? current + 1 : current;\n\n  const token = state.push(\"math_block\", \"math\", 0);\n\n  token.block = true;\n  token.content =\n    (firstLine ? `${firstLine}\\n` : \"\") +\n    state.getLines(start + 1, current, state.tShift[start], true) +\n    (lastLine ? `${lastLine}\\n` : \"\");\n  token.map = [start, state.line];\n  token.markup = \"$$\";\n\n  return true;\n};\n\n/*\n * Parse block math with bracket syntax: \\[...\\]\n */\nconst getBracketBlockTex = (): RuleBlock => (state, start, end, silent) => {\n  let pos = state.bMarks[start] + state.tShift[start];\n  let max = state.eMarks[start];\n\n  if (pos + 2 > max) return false;\n\n  if (state.src.slice(pos, pos + 2) !== \"\\\\[\") return false;\n\n  pos += 2;\n  let firstLine = state.src.slice(pos, max).trim();\n\n  if (silent) return true;\n\n  let found = false;\n\n  if (firstLine.endsWith(\"\\\\]\")) {\n    // Single line expression\n    firstLine = firstLine.slice(0, -2);\n    found = true;\n  }\n\n  let current = start;\n  let lastLine = \"\";\n\n  while (!found) {\n    current++;\n    if (current >= end) break;\n\n    pos = state.bMarks[current] + state.tShift[current];\n    max = state.eMarks[current];\n\n    // non-empty line with negative indent should stop the list:\n    if (pos < max && state.tShift[current] < state.blkIndent) break;\n\n    // found end marker\n    if (state.src.slice(pos, max).trim().endsWith(\"\\\\]\")) {\n      lastLine = state.src\n        .slice(pos, state.src.slice(0, max).lastIndexOf(\"\\\\]\"))\n        .trim();\n      found = true;\n    }\n  }\n\n  if (!found) return false;\n\n  state.line = current + 1;\n\n  const token = state.push(\"math_block\", \"math\", 0);\n\n  token.block = true;\n  token.content =\n    (firstLine ? `${firstLine}\\n` : \"\") +\n    state.getLines(start + 1, current, state.tShift[start], true) +\n    (lastLine ? `${lastLine}\\n` : \"\");\n  token.map = [start, state.line];\n  token.markup = \"\\\\[\";\n\n  return true;\n};\n\nexport const tex: PluginWithOptions<MarkdownItTexOptions> = (md, options) => {\n  if (typeof options?.render !== \"function\")\n    throw new Error('[@mdit/plugin-tex]: \"render\" option should be a function');\n\n  const {\n    allowInlineWithSpace = false,\n    mathFence = false,\n    delimiters = \"dollars\",\n    render,\n  } = options;\n\n  // Handle ```math blocks\n  if (mathFence) {\n    const fence = md.renderer.rules.fence;\n\n    md.renderer.rules.fence = (...args): string => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const [tokens, index, , env] = args;\n      const { content, info } = tokens[index];\n\n      if (info.trim() === \"math\") return render(content, true, env);\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return fence!(...args);\n    };\n  }\n\n  // Register inline and block rules based on delimiters option\n  if (delimiters === \"dollars\" || delimiters === \"all\") {\n    md.inline.ruler.after(\n      \"escape\",\n      \"math_inline_dollar\",\n      getDollarInlineTex(allowInlineWithSpace),\n    );\n    md.block.ruler.after(\n      \"blockquote\",\n      \"math_block_dollar\",\n      getDollarBlockTex(),\n      {\n        alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n      },\n    );\n  }\n\n  if (delimiters === \"brackets\" || delimiters === \"all\") {\n    md.inline.ruler.before(\n      \"escape\",\n      \"math_inline_bracket\",\n      getBracketInlineTex(),\n    );\n    md.block.ruler.after(\n      \"blockquote\",\n      \"math_block_bracket\",\n      getBracketBlockTex(),\n      {\n        alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n      },\n    );\n  }\n\n  md.renderer.rules.math_inline = (tokens, index, _options, env): string =>\n    render(tokens[index].content, false, env);\n  md.renderer.rules.math_block = (tokens, index, _options, env): string =>\n    render(tokens[index].content, true, env);\n};\n"],"names":["isValidDollarDelim","state","pos","allowInlineWithSpace","prevChar","nextChar","getDollarInlineTex","silent","delimState","start","match","token","getBracketInlineTex","found","backslashes","checkPos","closingBackslashes","closingCheckPos","getDollarBlockTex","end","max","firstLine","current","lastLine","getBracketBlockTex","tex","md","options","mathFence","delimiters","render","fence","args","tokens","index","env","content","info","_options"],"mappings":"AAeA,MAAMA,EAAqB,CACzBC,EACAC,EACAC,IAC4C,CAC5C,MAAMC,EAAWH,EAAM,IAAI,OAAOC,EAAM,CAAC,EACnCG,EAAWJ,EAAM,IAAI,OAAOC,EAAM,CAAC,EAEzC,MAAO,CACL,QAASC,GAAyBE,IAAa,KAAOA,IAAa,IAMnE,SACE,CAAC,SAAS,KAAKA,CAAQ,IACtBF,GAAyBC,IAAa,KAAOA,IAAa,IAC/D,CACF,EAKME,EACHH,GACD,CAACF,EAAOM,IAAW,CACjB,GAAIN,EAAM,IAAIA,EAAM,GAAG,IAAM,IAAK,SAElC,IAAIO,EAAaR,EAAmBC,EAAOA,EAAM,IAAKE,CAAoB,EAE1E,GAAI,CAACK,EAAW,QACd,OAAKD,IAAQN,EAAM,SAAW,KAE9BA,EAAM,MAEC,GAST,MAAMQ,EAAQR,EAAM,IAAM,EAE1B,IAAIS,EAAQD,EACRP,EAEJ,MAAQQ,EAAQT,EAAM,IAAI,QAAQ,IAAKS,CAAK,KAAO,IAAI,CAMrD,IADAR,EAAMQ,EAAQ,EACPT,EAAM,IAAIC,CAAG,IAAM,MAAMA,IAGhC,IAAKQ,EAAQR,GAAO,IAAM,EAAG,MAE7BQ,GACF,CAGA,GAAIA,IAAU,GACZ,OAAKH,IAAQN,EAAM,SAAW,KAE9BA,EAAM,IAAMQ,EAEL,GAIT,GAAIC,EAAQD,IAAU,EACpB,OAAKF,IAAQN,EAAM,SAAW,MAE9BA,EAAM,IAAMQ,EAAQ,EAEb,GAMT,GAFAD,EAAaR,EAAmBC,EAAOS,EAAOP,CAAoB,EAE9D,CAACK,EAAW,SACd,OAAKD,IAAQN,EAAM,SAAW,KAE9BA,EAAM,IAAMQ,EAEL,GAGT,GAAI,CAACF,EAAQ,CACX,MAAMI,EAAQV,EAAM,KAAK,cAAe,OAAQ,CAAC,EAEjDU,EAAM,OAAS,IACfA,EAAM,QAAUV,EAAM,IAAI,MAAMQ,EAAOC,CAAK,CAC9C,CAEA,OAAAT,EAAM,IAAMS,EAAQ,EAEb,EACT,EAKIE,EAAsB,IAAkB,CAACX,EAAOM,IAAW,CAC/D,MAAME,EAAQR,EAAM,IAGpB,GAAIA,EAAM,IAAI,MAAMQ,EAAOA,EAAQ,CAAC,IAAM,MAAO,MAAO,GAGxD,IAAIP,EAAMO,EAAQ,EACdI,EAAQ,GAEZ,KAAOX,EAAMD,EAAM,IAAI,OAAS,GAAG,CACjC,GAAIA,EAAM,IAAI,MAAMC,EAAKA,EAAM,CAAC,IAAM,MAAO,CAE3C,IAAIY,EAAc,EACdC,EAAWN,EAAQ,EAEvB,KAAOM,GAAY,GAAKd,EAAM,IAAIc,CAAQ,IAAM,MAC9CD,IACAC,IAIF,GAAID,EAAc,IAAM,EAAG,MAAO,GAGlC,IAAIE,EAAqB,EACrBC,EAAkBf,EAAM,EAE5B,KACEe,GAAmBR,EAAQ,GAC3BR,EAAM,IAAIgB,CAAe,IAAM,MAE/BD,IACAC,IAIF,GAAID,EAAqB,IAAM,EAAG,CAChCH,EAAQ,GACR,KACF,CACF,CACAX,GACF,CAEA,GAAI,CAACW,EAAO,MAAO,GAEnB,GAAI,CAACN,EAAQ,CACX,MAAMI,EAAQV,EAAM,KAAK,cAAe,OAAQ,CAAC,EAEjDU,EAAM,OAAS,MACfA,EAAM,QAAUV,EAAM,IAAI,MAAMQ,EAAQ,EAAGP,CAAG,CAChD,CAEA,OAAAD,EAAM,IAAMC,EAAM,EAEX,EACT,EAKMgB,EAAoB,IAAiB,CAACjB,EAAOQ,EAAOU,EAAKZ,IAAW,CACxE,IAAIL,EAAMD,EAAM,OAAOQ,CAAK,EAAIR,EAAM,OAAOQ,CAAK,EAC9CW,EAAMnB,EAAM,OAAOQ,CAAK,EAI5B,GAFIP,EAAM,EAAIkB,GAEVnB,EAAM,IAAI,MAAMC,EAAKA,EAAM,CAAC,IAAM,KAAM,SAE5CA,GAAO,EACP,IAAImB,EAAYpB,EAAM,IAAI,MAAMC,EAAKkB,CAAG,EAAE,KAAK,EAE/C,GAAIb,EAAQ,MAAO,GAEnB,IAAIM,EAAQ,GAERQ,EAAU,SAAS,IAAI,IAEzBA,EAAYA,EAAU,MAAM,EAAG,EAAE,EACjCR,EAAQ,IAGV,IAAIS,EAAUb,EACVc,EAAW,GAEf,KAAO,CAACV,IACNS,IACI,EAAAA,GAAWH,IAEfjB,EAAMD,EAAM,OAAOqB,CAAO,EAAIrB,EAAM,OAAOqB,CAAO,EAClDF,EAAMnB,EAAM,OAAOqB,CAAO,EAGtBpB,EAAMkB,GAAOnB,EAAM,OAAOqB,CAAO,EAAIrB,EAAM,cAG3CA,EAAM,IAAI,MAAMC,EAAKkB,CAAG,EAAE,KAAA,EAAO,SAAS,IAAI,IAChDG,EAAWtB,EAAM,IACd,MAAMC,EAAKD,EAAM,IAAI,MAAM,EAAGmB,CAAG,EAAE,YAAY,IAAI,CAAC,EACpD,OACHP,EAAQ,IAIZZ,EAAM,KAAOY,EAAQS,EAAU,EAAIA,EAEnC,MAAMX,EAAQV,EAAM,KAAK,aAAc,OAAQ,CAAC,EAEhD,OAAAU,EAAM,MAAQ,GACdA,EAAM,SACHU,EAAY,GAAGA,CAAS;AAAA,EAAO,IAChCpB,EAAM,SAASQ,EAAQ,EAAGa,EAASrB,EAAM,OAAOQ,CAAK,EAAG,EAAI,GAC3Dc,EAAW,GAAGA,CAAQ;AAAA,EAAO,IAChCZ,EAAM,IAAM,CAACF,EAAOR,EAAM,IAAI,EAC9BU,EAAM,OAAS,KAER,EACT,EAKMa,EAAqB,IAAiB,CAACvB,EAAOQ,EAAOU,EAAKZ,IAAW,CACzE,IAAIL,EAAMD,EAAM,OAAOQ,CAAK,EAAIR,EAAM,OAAOQ,CAAK,EAC9CW,EAAMnB,EAAM,OAAOQ,CAAK,EAI5B,GAFIP,EAAM,EAAIkB,GAEVnB,EAAM,IAAI,MAAMC,EAAKA,EAAM,CAAC,IAAM,MAAO,SAE7CA,GAAO,EACP,IAAImB,EAAYpB,EAAM,IAAI,MAAMC,EAAKkB,CAAG,EAAE,OAE1C,GAAIb,EAAQ,SAEZ,IAAIM,EAAQ,GAERQ,EAAU,SAAS,KAAK,IAE1BA,EAAYA,EAAU,MAAM,EAAG,EAAE,EACjCR,EAAQ,IAGV,IAAIS,EAAUb,EACVc,EAAW,GAEf,KAAO,CAACV,IACNS,IACI,EAAAA,GAAWH,IAEfjB,EAAMD,EAAM,OAAOqB,CAAO,EAAIrB,EAAM,OAAOqB,CAAO,EAClDF,EAAMnB,EAAM,OAAOqB,CAAO,EAGtBpB,EAAMkB,GAAOnB,EAAM,OAAOqB,CAAO,EAAIrB,EAAM,cAG3CA,EAAM,IAAI,MAAMC,EAAKkB,CAAG,EAAE,KAAA,EAAO,SAAS,KAAK,IACjDG,EAAWtB,EAAM,IACd,MAAMC,EAAKD,EAAM,IAAI,MAAM,EAAGmB,CAAG,EAAE,YAAY,KAAK,CAAC,EACrD,KACHP,EAAAA,EAAQ,IAIZ,GAAI,CAACA,EAAO,SAEZZ,EAAM,KAAOqB,EAAU,EAEvB,MAAMX,EAAQV,EAAM,KAAK,aAAc,OAAQ,CAAC,EAEhD,OAAAU,EAAM,MAAQ,GACdA,EAAM,SACHU,EAAY,GAAGA,CAAS;AAAA,EAAO,IAChCpB,EAAM,SAASQ,EAAQ,EAAGa,EAASrB,EAAM,OAAOQ,CAAK,EAAG,EAAI,GAC3Dc,EAAW,GAAGA,CAAQ;AAAA,EAAO,IAChCZ,EAAM,IAAM,CAACF,EAAOR,EAAM,IAAI,EAC9BU,EAAM,OAAS,MAER,EACT,EAEac,EAA+C,CAACC,EAAIC,IAAY,CAC3E,GAAI,OAAOA,GAAS,QAAW,WAC7B,MAAM,IAAI,MAAM,0DAA0D,EAE5E,KAAM,CACJ,qBAAAxB,EAAuB,GACvB,UAAAyB,EAAY,GACZ,WAAAC,EAAa,UACb,OAAAC,CACF,EAAIH,EAGJ,GAAIC,EAAW,CACb,MAAMG,EAAQL,EAAG,SAAS,MAAM,MAEhCA,EAAG,SAAS,MAAM,MAAQ,IAAIM,IAAiB,CAE7C,KAAM,CAACC,EAAQC,EAASC,CAAAA,CAAG,EAAIH,EACzB,CAAE,QAAAI,EAAS,KAAAC,CAAK,EAAIJ,EAAOC,CAAK,EAEtC,OAAIG,EAAK,SAAW,OAAeP,EAAOM,EAAS,GAAMD,CAAG,EAGrDJ,EAAO,GAAGC,CAAI,CACvB,CACF,EAGIH,IAAe,WAAaA,IAAe,SAC7CH,EAAG,OAAO,MAAM,MACd,SACA,qBACApB,EAAmBH,CAAoB,CACzC,EACAuB,EAAG,MAAM,MAAM,MACb,aACA,oBACAR,EAAkB,EAClB,CACE,IAAK,CAAC,YAAa,YAAa,aAAc,MAAM,CACtD,CACF,IAGEW,IAAe,YAAcA,IAAe,SAC9CH,EAAG,OAAO,MAAM,OACd,SACA,sBACAd,EACF,CAAA,EACAc,EAAG,MAAM,MAAM,MACb,aACA,qBACAF,IACA,CACE,IAAK,CAAC,YAAa,YAAa,aAAc,MAAM,CACtD,CACF,GAGFE,EAAG,SAAS,MAAM,YAAc,CAACO,EAAQC,EAAOI,EAAUH,IACxDL,EAAOG,EAAOC,CAAK,EAAE,QAAS,GAAOC,CAAG,EAC1CT,EAAG,SAAS,MAAM,WAAa,CAACO,EAAQC,EAAOI,EAAUH,IACvDL,EAAOG,EAAOC,CAAK,EAAE,QAAS,GAAMC,CAAG,CAC3C"}