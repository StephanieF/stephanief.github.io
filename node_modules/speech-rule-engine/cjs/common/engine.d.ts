import { AuditoryDescription } from '../audio/auditory_description.js';
import * as Dcstr from '../rule_engine/dynamic_cstr.js';
import * as EngineConst from './engine_const.js';
import { Options } from './options.js';
export declare class SREError extends Error {
    message: string;
    name: string;
    constructor(message?: string);
}
export declare class Engine {
    options: Options;
    config: boolean;
    private static instance;
    customLoader: (locale: string) => Promise<string>;
    evaluator: (p1: string, p2: Dcstr.DynamicCstr) => string | null;
    defaultParser: Dcstr.DynamicCstrParser;
    parser: Dcstr.DynamicCstrParser;
    parsers: {
        [key: string]: Dcstr.DynamicCstrParser;
    };
    dynamicCstr: Dcstr.DynamicCstr;
    comparator: Dcstr.Comparator;
    mode: EngineConst.Mode;
    init: boolean;
    comparators: {
        [key: string]: () => Dcstr.Comparator;
    };
    private _defaultLocale;
    set defaultLocale(loc: string);
    get defaultLocale(): string;
    static getInstance(): Engine;
    static defaultEvaluator(str: string, _cstr: Dcstr.DynamicCstr): string;
    static nodeEvaluator: (node: Element) => AuditoryDescription[];
    static evaluateNode(node: Element): AuditoryDescription[];
    getRate(): number;
    setDynamicCstr(opt_dynamic?: Dcstr.AxisMap): void;
    private constructor();
    configurate(feature: {
        [key: string]: boolean | string;
    }): void;
    setCustomLoader(fn: any): void;
    setup(feature: {
        [key: string]: boolean | string;
    }): void;
    json(): {
        [key: string]: boolean | string;
    };
    reset(): void;
}
export declare class EnginePromise {
    static loaded: {
        [locale: string]: [boolean, boolean];
    };
    static promises: {
        [locale: string]: Promise<string>;
    };
    static get(locale?: string): Promise<string>;
    static getall(): Promise<string[]>;
}
