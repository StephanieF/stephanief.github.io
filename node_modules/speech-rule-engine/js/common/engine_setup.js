var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as L10n from '../l10n/l10n.js';
import * as MathMap from '../speech_rules/math_map.js';
import { Debugger } from './debugger.js';
import { Engine, EnginePromise } from './engine.js';
import { SystemExternal } from './system_external.js';
export function setupEngine(feature) {
    return __awaiter(this, void 0, void 0, function* () {
        if (feature.debug) {
            Debugger.getInstance().init();
        }
        const engine = Engine.getInstance();
        engine.setup(feature);
        L10n.setLocale();
        engine.setDynamicCstr();
        if (engine.init) {
            EnginePromise.promises['init'] = new Promise((res, _rej) => {
                setTimeout(() => {
                    res('init');
                }, 10);
            });
            engine.init = false;
            return EnginePromise.get();
        }
        if (engine.options.delay) {
            engine.options.delay = false;
            return EnginePromise.get();
        }
        return MathMap.loadLocale();
    });
}
export function engineSetup() {
    const features = Engine.getInstance().json();
    features.json = SystemExternal.jsonPath;
    return features;
}
//# sourceMappingURL=engine_setup.js.map