import { setupEngine } from '../common/engine_setup.js';
import * as EnrichAttr from '../enrich_mathml/enrich_attr.js';
import { RebuildStree } from '../walker/rebuild_stree.js';
import * as SpeechGeneratorUtil from './speech_generator_util.js';
import { LOCALE } from '../l10n/locale.js';
export class AbstractSpeechGenerator {
    constructor() {
        this.modality = EnrichAttr.addPrefix('speech');
        this.rebuilt_ = null;
        this.options_ = {};
    }
    getRebuilt() {
        return this.rebuilt_;
    }
    setRebuilt(rebuilt) {
        this.rebuilt_ = rebuilt;
    }
    computeRebuilt(xml, force = false) {
        if (!this.rebuilt_ || force) {
            this.rebuilt_ = new RebuildStree(xml);
        }
        return this.rebuilt_;
    }
    setOptions(options) {
        this.options_ = options || {};
        this.modality = EnrichAttr.addPrefix(this.options_.modality || 'speech');
    }
    setOption(key, value) {
        const options = this.getOptions();
        options[key] = value;
        this.setOptions(options);
    }
    getOptions() {
        return this.options_;
    }
    generateSpeech(_node, xml) {
        if (!this.rebuilt_) {
            this.rebuilt_ = new RebuildStree(xml);
        }
        setupEngine(this.options_);
        return SpeechGeneratorUtil.computeMarkup(this.getRebuilt().xml);
    }
    nextRules() {
        this.setOptions(SpeechGeneratorUtil.nextRules(this.getOptions()));
    }
    nextStyle(id) {
        this.setOption('style', SpeechGeneratorUtil.nextStyle(this.getRebuilt().nodeDict[id], this.getOptions()));
    }
    getLevel(depth) {
        return LOCALE.MESSAGES.navigate.LEVEL + ' ' + depth;
    }
    getActionable(actionable) {
        return actionable
            ? actionable < 0
                ? LOCALE.MESSAGES.navigate.EXPANDABLE
                : LOCALE.MESSAGES.navigate.COLLAPSIBLE
            : '';
    }
}
//# sourceMappingURL=abstract_speech_generator.js.map