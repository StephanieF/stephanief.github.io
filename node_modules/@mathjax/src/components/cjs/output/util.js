"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OutputUtil = void 0;
exports.configFont = configFont;
exports.configExtensions = configExtensions;
var global_js_1 = require("#js/components/global.js");
var package_js_1 = require("#js/components/package.js");
var context_js_1 = require("#js/util/context.js");
var mathjax_js_1 = require("#js/mathjax.js");
function configFont(font, jax, config, extension) {
    var _a;
    var _b, _c;
    if (extension === void 0) { extension = ''; }
    var version = (((_c = (_b = MathJax.config.loader) === null || _b === void 0 ? void 0 : _b.paths) === null || _c === void 0 ? void 0 : _c.fonts) || '').substring(0, 24) === 'https://cdn.jsdelivr.net'
        ? "@%%VERSION%%" : '';
    var path = (config.fontPath || "[fonts]/%%FONT%%-font".concat(extension).concat(version));
    var name = (font.match(/^[a-z]+:/) ? (font.match(/[^/:\\]*$/) || [jax])[0] : font);
    (0, global_js_1.combineDefaults)(MathJax.config.loader, 'paths', (_a = {},
        _a[name + extension] = (name === font
            ? path.replace(/%%FONT%%/g, font).replace(/%%VERSION%%/g, mathjax_js_1.mathjax.version)
            : font),
        _a));
    return "[".concat(name).concat(extension, "]");
}
function configExtensions(jax, config) {
    var e_1, _a;
    var extensions = [];
    try {
        for (var _b = __values((config.fontExtensions || [])), _c = _b.next(); !_c.done; _c = _b.next()) {
            var name_1 = _c.value;
            var font = configFont(name_1, jax, config, '-extension');
            var module = "".concat(font, "/").concat(jax);
            extensions.push(module);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return extensions;
}
exports.OutputUtil = {
    config: function (jax, jaxClass, defaultFont, fontClass) {
        var _a, _b, _c, _d;
        var _e;
        if (MathJax.loader) {
            (0, global_js_1.combineDefaults)(MathJax.config, jax, MathJax.config.output || {});
            var config = MathJax.config[jax];
            var font = config.font || config.fontData || defaultFont;
            if (typeof (font) !== 'string') {
                config.fontData = font;
                config.font = font = font.NAME;
            }
            if (font.charAt(0) !== '[') {
                font = configFont(font, jax, config);
            }
            var name_2 = font.substring(1, font.length - 1);
            var extensions = configExtensions(jax, config);
            if (extensions.length) {
                MathJax.loader.addPackageData("".concat(font, "/").concat(jax), { extraLoads: extensions });
            }
            if (name_2 !== defaultFont || !fontClass) {
                MathJax.loader.addPackageData("output/".concat(jax), { extraLoads: ["".concat(font, "/").concat(jax)] });
            }
            else {
                var extraLoads = (_e = MathJax.config.loader["".concat(font, "/").concat(jax)]) === null || _e === void 0 ? void 0 : _e.extraLoads;
                if (extraLoads) {
                    MathJax.loader.addPackageData("output/".concat(jax), { extraLoads: extraLoads });
                }
                (0, global_js_1.combineWithMathJax)({ _: {
                        output: {
                            fonts: (_a = {},
                                _a[name_2] = (_b = {},
                                    _b[jax + '_ts'] = (_c = {},
                                        _c[fontClass.NAME + 'Font'] = fontClass,
                                        _c),
                                    _b),
                                _a)
                        }
                    } });
                (0, global_js_1.combineDefaults)(MathJax, 'config', (_d = {
                        output: {
                            font: font,
                        }
                    },
                    _d[jax] = {
                        fontData: fontClass,
                        dynamicPrefix: "".concat(font, "/").concat(jax, "/dynamic")
                    },
                    _d));
                if (jax === 'chtml') {
                    (0, global_js_1.combineDefaults)(MathJax.config, jax, {
                        fontURL: package_js_1.Package.resolvePath("".concat(font, "/").concat(jax, "/woff2"), false),
                    });
                }
            }
        }
        if (MathJax.startup) {
            MathJax.startup.registerConstructor(jax, jaxClass);
            MathJax.startup.useOutput(jax);
        }
    },
    loadFont: function (startup, jax, font, preloaded) {
        if (!MathJax.loader) {
            return startup;
        }
        if (preloaded) {
            MathJax.loader.preLoaded("[".concat(font, "]/").concat(jax));
        }
        return package_js_1.Package.loadPromise("output/".concat(jax)).then(startup);
    }
};
